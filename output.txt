cc  -g 	compiler.c \
			get_next_linev2/get_next_line.c\
			get_next_linev2/get_next_line_utils.c\
		-o รงc
mkdir -p `dirname ./build/spec-mvp.ce`
touch .a.txt
cp .a.txt .b.txt
touch .b.txt
echo "oka"
oka
cp -n "ft_cedille_spec/spec-mvp.รง" "./build/spec-mvp.ce" || echo ""
valgrind --leak-check=full --show-leak-kinds=all ./รงc -I./ft_cedille_spec ./build/spec-mvp.ce -e -compiler.c -o ./
output path	: ./
output sufix	: -compiler.c
includes[]	: /usr/include
includes[]	: /usr/local/include
includes[]	: ./ft_cedille_spec
sources[]	: ./build/spec-mvp.ce
__________
#parsing: ./build/spec-mvp.ce
0:	#
1:	import
2:	"
3:	รง
4:	"
__________
#parsing: รง
-- parse(รง) returned 4242
__________
#parsing: /usr/include/รง
-- parse(/usr/include/รง) returned 4242
__________
#parsing: /usr/local/include/รง
-- parse(/usr/local/include/รง) returned 4242
__________
#parsing: ./ft_cedille_spec/รง
0:	#
1:	ifndef
2:	FT_CEDILLE_H
3:	#
4:	define
5:	FT_CEDILLE_H
6:	#
7:	define
8:	TOKENPASTE
9:	(
10:	x
11:	,
12:	y
13:	)
14:	x
15:	#
16:	#
17:	y
18:	#
19:	define
20:	TOKENPASTE2
21:	(
22:	x
23:	,
24:	y
25:	)
26:	TOKENPASTE
27:	(
28:	x
29:	,
30:	y
31:	)
32:	#
33:	define
34:	rule
35:	(
36:	.
37:	.
38:	.
39:	)
40:	TOKENPASTE2
41:	(
42:	char
43:	*
44:	r_
45:	,
46:	__LINE__
47:	)
48:	(
49:	int
50:	i
51:	,
52:	int
53:	x
54:	,
55:	char
56:	*
57:	s
58:	)
59:	#
60:	define
61:	macro
62:	#
63:	define
64:	cat
65:	(
66:	.
67:	.
68:	.
69:	)
70:	"
71:	"
72:	#
73:	endif
__________
5:	#
6:	import
7:	"
8:	spec
9:	-
10:	mvp2
11:	.
12:	รง
13:	"
__________
#parsing: spec-mvp2.รง
-- parse(spec-mvp2.รง) returned 4242
__________
#parsing: /usr/include/spec-mvp2.รง
-- parse(/usr/include/spec-mvp2.รง) returned 4242
__________
#parsing: /usr/local/include/spec-mvp2.รง
-- parse(/usr/local/include/spec-mvp2.รง) returned 4242
__________
#parsing: ./ft_cedille_spec/spec-mvp2.รง
0:	#
1:	import
2:	"
3:	รง
4:	"
[1mรง:1:1: [31merror: [0m[1mFile 'รง' already included !
[0m
5:	#
6:	define
7:	semicolon
8:	'
9:	;
10:	'
11:	macro
12:	int
13:	g
14:	(
15:	int
16:	z
17:	)
18:	{
19:	return
20:	z
21:	;
22:	}
23:	macro
24:	rule
25:	(
26:	<
27:	s
28:	[
29:	x
30:	+
31:	y
32:	]
33:	=
34:	=
35:	0
36:	;
37:	0
38:	;
39:	>
40:	)
41:	{
42:	return
43:	(
44:	cat
45:	(
46:	"
47:	!
48:	!
49:	 
50:	"
51:	)
52:	)
53:	;
54:	}
Macro pattern[pattern='
	< s[x+y] == 0 ; 0 ;>
'
	body='
	return (cat("!! "));
']
__________
14:	#
15:	include
16:	"
17:	stdio
18:	.
19:	h
20:	"
21:	#
22:	include
23:	"
24:	string
25:	.
26:	h
27:	"
28:	#
29:	include
30:	<
31:	ctype
32:	.
33:	h
34:	>
35:	macro
36:	int
37:	m_state_test
38:	=
39:	0
40:	;
41:	macro
42:	int
43:	m_brace_level
44:	=
45:	0
46:	;
47:	macro
48:	int
49:	m_bracket_level
50:	=
51:	0
52:	;
53:	macro
54:	int
55:	m_parenthesis_level
56:	=
57:	0
58:	;
59:	macro
60:	int
61:	f
62:	(
63:	int
64:	x
65:	)
66:	{
67:	return
68:	(
69:	x
70:	)
71:	;
72:	}
73:	/
74:	*
75:	

76:		
77:	<
78:	continue
79:	 
80:	while
81:	 
82:	;
83:	 
84:	succeed
85:	 
86:	on
87:	 
88:	;
89:	>
90:	

91:	*
92:	/
93:	/
94:	/
95:	 
96:	test
97:	

98:	macro
99:	rule
100:	(
101:	<
102:	s
103:	[
104:	x
105:	+
106:	y
107:	]
108:	=
109:	=
110:	"
111:	Hello
112:	 
113:	"
114:	[
115:	y
116:	]
117:	;
118:	y
119:	=
120:	=
121:	5
122:	;
123:	>
124:	<
125:	(
126:	test2
127:	[
128:	y
129:	]
130:	=
131:	s
132:	[
133:	x
134:	+
135:	y
136:	]
137:	)
138:	&&
139:	y
140:	<
141:	5
142:	;
143:	s
144:	[
145:	x
146:	+
147:	y
148:	]
149:	=
150:	=
151:	"
152:	!
153:	"
154:	[
155:	0
156:	]
157:	&&
158:	!
159:	(
160:	test2
161:	[
162:	y
163:	]
164:	=
165:	0
166:	)
167:	;
168:	>
169:	)
170:	{
171:	m_state_test
172:	+
173:	=
174:	1
175:	;
176:	return
177:	(
178:	cat
179:	(
180:	"
181:	Good
182:	 
183:	night
184:	 
185:	dear
186:	 
187:	"
188:	,
189:	test2
190:	,
191:	"
192:	.
193:	"
194:	)
195:	)
196:	;
197:	}
Macro pattern[pattern='
	<s[x + y] == "Hello "[y]				;	y == 5;>
		<(test2[y] = s[x + y]) && y < 5		;	s[x + y] == "!"[0]	&& !(test2[y] = 0);>
'
	body='
	m_state_test += 1;
	return(cat("Good night dear ", test2, "."));
']
198:	macro
199:	char
200:	*
201:	trim
202:	(
203:	char
204:	*
205:	str
206:	)
207:	{
208:	int
209:	i
210:	;
211:	char
212:	*
213:	o
214:	;
215:	while
216:	(
217:	*
218:	str
219:	&&
220:	isspace
221:	(
222:	*
223:	str
224:	)
225:	)
226:	{
227:	str
228:	+
229:	=
230:	1
231:	;
232:	}
233:	i
234:	=
235:	0
236:	;
237:	while
238:	(
239:	str
240:	[
241:	i
242:	]
243:	&&
244:	!
245:	isspace
246:	(
247:	str
248:	[
249:	i
250:	]
251:	)
252:	)
253:	{
254:	i
255:	+
256:	=
257:	1
258:	;
259:	}
260:	asprintf
261:	(
262:	&o
263:	,
264:	"
265:	%
266:	.
267:	*
268:	s
269:	"
270:	,
271:	i
272:	,
273:	str
274:	)
275:	;
276:	return
277:	(
278:	o
279:	)
280:	;
281:	}
282:	macro
283:	char
284:	*
285:	lastword
286:	(
287:	char
288:	*
289:	str
290:	)
291:	{
292:	char
293:	*
294:	lastspace
295:	;
296:	int
297:	i
298:	;
299:	i
300:	=
301:	0
302:	;
303:	while
304:	(
305:	str
306:	[
307:	i
308:	]
309:	)
310:	i
311:	+
312:	=
313:	1
314:	;
315:	while
316:	(
317:	(
318:	i
319:	-
320:	1
321:	)
322:	&&
323:	isspace
324:	(
325:	str
326:	[
327:	i
328:	-
329:	1
330:	]
331:	)
332:	)
333:	i
334:	-
335:	=
336:	1
337:	;
338:	while
339:	(
340:	(
341:	i
342:	-
343:	1
344:	)
345:	&&
346:	!
347:	isspace
348:	(
349:	str
350:	[
351:	i
352:	-
353:	1
354:	]
355:	)
356:	)
357:	i
358:	-
359:	=
360:	1
361:	;
362:	return
363:	(
364:	str
365:	+
366:	i
367:	)
368:	;
369:	}
370:	/
371:	*
372:	 
373:	TODO
374:	:
375:	 
376:	deeper
377:	 
378:	parse
379:	 
380:	-
381:	 
382:	f
383:	(
384:	await
385:	 
386:	g
387:	(
388:	.
389:	.
390:	.
391:	)
392:	[
393:	await
394:	 
395:	h
396:	(
397:	.
398:	.
399:	.
400:	)
401:	 
402:	+
403:	 
404:	await
405:	 
406:	i
407:	(
408:	.
409:	.
410:	.
411:	)
412:	]
413:	)
414:	 
415:	*
416:	/
417:	#
418:	define
419:	await
420:	macro
421:	rule
422:	(
423:	<
424:	(
425:	prev
426:	[
427:	0
428:	]
429:	=
430:	s
431:	[
432:	x
433:	]
434:	)
435:	&&
436:	(
437:	s
438:	[
439:	x
440:	]
441:	=
442:	=
443:	'
444:	{
445:	'
446:	||
447:	s
448:	[
449:	x
450:	]
451:	=
452:	=
453:	semicolon
454:	)
455:	;
456:	(
457:	!
458:	(
459:	prev
460:	[
461:	1
462:	]
463:	=
464:	0
465:	)
466:	)
467:	;
468:	>
469:	<
470:	(
471:	assignation
472:	[
473:	y
474:	]
475:	=
476:	s
477:	[
478:	x
479:	+
480:	y
481:	]
482:	)
483:	&&
484:	(
485:	s
486:	[
487:	x
488:	+
489:	y
490:	]
491:	!
492:	=
493:	'
494:	{
495:	'
496:	&&
497:	s
498:	[
499:	x
500:	+
501:	y
502:	]
503:	!
504:	=
505:	semicolon
506:	)
507:	;
508:	(
509:	s
510:	[
511:	x
512:	+
513:	y
514:	]
515:	=
516:	=
517:	'
518:	=
519:	'
520:	||
521:	(
522:	(
523:	s
524:	[
525:	x
526:	+
527:	y
528:	]
529:	=
530:	=
531:	'
532:	a
533:	'
534:	&&
535:	s
536:	[
537:	x
538:	+
539:	y
540:	+
541:	1
542:	]
543:	=
544:	=
545:	'
546:	w
547:	'
548:	)
549:	&&
550:	(
551:	-
552:	-
553:	x
554:	||
555:	1
556:	)
557:	)
558:	)
559:	&&
560:	!
561:	(
562:	assignation
563:	[
564:	y
565:	]
566:	=
567:	0
568:	)
569:	;
570:	>
571:	<
572:	x
573:	;
574:	!
575:	isspace
576:	(
577:	s
578:	[
579:	x
580:	+
581:	y
582:	]
583:	)
584:	&&
585:	(
586:	-
587:	-
588:	x
589:	||
590:	1
591:	)
592:	;
593:	>
594:	<
595:	s
596:	[
597:	x
598:	+
599:	y
600:	]
601:	=
602:	=
603:	"
604:	await
605:	"
606:	[
607:	y
608:	]
609:	;
610:	y
611:	=
612:	=
613:	4
614:	;
615:	>
616:	<
617:	(
618:	name
619:	[
620:	y
621:	]
622:	=
623:	s
624:	[
625:	x
626:	+
627:	y
628:	]
629:	)
630:	&&
631:	y
632:	<
633:	8
634:	&&
635:	s
636:	[
637:	x
638:	+
639:	y
640:	]
641:	;
642:	s
643:	[
644:	x
645:	+
646:	y
647:	]
648:	=
649:	=
650:	'
651:	(
652:	'
653:	&&
654:	!
655:	(
656:	(
657:	name
658:	[
659:	y
660:	]
661:	=
662:	0
663:	)
664:	||
665:	(
666:	m_parenthesis_level
667:	=
668:	0
669:	)
670:	)
671:	;
672:	>
673:	<
674:	(
675:	args
676:	[
677:	y
678:	]
679:	=
680:	s
681:	[
682:	x
683:	+
684:	y
685:	]
686:	)
687:	&&
688:	(
689:	(
690:	(
691:	s
692:	[
693:	x
694:	+
695:	y
696:	]
697:	=
698:	=
699:	'
700:	(
701:	'
702:	)
703:	&&
704:	+
705:	+
706:	m_parenthesis_level
707:	)
708:	||
709:	1
710:	)
711:	;
712:	(
713:	s
714:	[
715:	x
716:	+
717:	y
718:	]
719:	=
720:	=
721:	'
722:	)
723:	'
724:	&&
725:	!
726:	(
727:	m_parenthesis_level
728:	<
729:	0
730:	)
731:	)
732:	&&
733:	!
734:	(
735:	(
736:	args
737:	[
738:	y
739:	]
740:	=
741:	0
742:	)
743:	||
744:	(
745:	m_brace_level
746:	=
747:	0
748:	)
749:	)
750:	;
751:	>
752:	<
753:	(
754:	body
755:	[
756:	y
757:	]
758:	=
759:	s
760:	[
761:	x
762:	+
763:	y
764:	]
765:	)
766:	&&
767:	(
768:	(
769:	(
770:	s
771:	[
772:	x
773:	+
774:	y
775:	]
776:	=
777:	=
778:	'
779:	{
780:	'
781:	&&
782:	+
783:	+
784:	m_brace_level
785:	)
786:	||
787:	(
788:	s
789:	[
790:	x
791:	+
792:	y
793:	]
794:	=
795:	=
796:	'
797:	}
798:	'
799:	&&
800:	(
801:	m_brace_level
802:	-
803:	-
804:	||
805:	1
806:	)
807:	)
808:	)
809:	||
810:	1
811:	)
812:	;
813:	(
814:	s
815:	[
816:	x
817:	+
818:	y
819:	]
820:	=
821:	=
822:	'
823:	}
824:	'
825:	&&
826:	m_brace_level
827:	<
828:	0
829:	)
830:	&&
831:	!
832:	(
833:	body
834:	[
835:	y
836:	]
837:	=
838:	0
839:	)
840:	;
841:	>
842:	)
843:	{
844:	char
845:	*
846:	o
847:	;
848:	asprintf
849:	(
850:	&o
851:	,
852:	"
853:	%s
854:	\
855:	n%s
856:	(
857:	%s%s
858:	 
859:	^
860:	(
861:	typeof
862:	(
863:	%s
864:	(
865:	%s%s
866:	 
867:	0
868:	)
869:	)
870:	 
871:	%s
872:	)
873:	 
874:	{
875:	 
876:	%s
877:	 
878:	}
879:	)
880:	;
881:	\
882:	n
883:	}
884:	"
885:	,
886:	cat
887:	(
888:	prev
889:	)
890:	,
891:	cat
892:	(
893:	name
894:	)
895:	,
896:	cat
897:	(
898:	args
899:	)
900:	,
901:	strlen
902:	(
903:	cat
904:	(
905:	args
906:	)
907:	)
908:	?
909:	"
910:	,
911:	"
912:	:
913:	"
914:	"
915:	,
916:	cat
917:	(
918:	name
919:	)
920:	,
921:	cat
922:	(
923:	args
924:	)
925:	,
926:	strlen
927:	(
928:	cat
929:	(
930:	args
931:	)
932:	)
933:	?
934:	"
935:	,
936:	"
937:	:
938:	"
939:	"
940:	,
941:	lastword
942:	(
943:	cat
944:	(
945:	assignation
946:	)
947:	)
948:	,
949:	cat
950:	(
951:	body
952:	)
953:	)
954:	;
955:	return
956:	(
957:	o
958:	)
959:	;
960:	}
Macro pattern[pattern='
	<
		(prev[0] = s[x])
		&&
		(
			s[x] == '{'
			||
			s[x] == semicolon
		)
		;
		(
			!(prev[1] = 0)
		)
	;>
	<
		(assignation[y] = s[x + y])
		&& 
		(
			s[x + y] != '{' 
			&& 
			s[x + y] != semicolon)
		;
		(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1)))
		&&
		!(assignation[y] = 0)
	;>
	<x
	; 
	!isspace(s[x + y]) && (--x || 1);>
	<s[x + y] == "await"[y]							; 	y == 4;>
		<(name[y] = s[x + y]) && y < 8 && s[x + y]	
		;	
		s[x + y] == '(' 
		&&
		!(
			(name[y] = 0)
			||
			(m_parenthesis_level = 0)
		)
		;>
				<(args[y] = s[x + y]) 
				&&
				(((s[x + y] == '(')
				&&
				++m_parenthesis_level) || 1)
				;
					(
						s[x + y] == ')'
						&&
						!(m_parenthesis_level < 0)
					)
					&& 
					!(
						(args[y] = 0) 
						||
						(m_brace_level = 0)
					)
				;>
					<(body[y] = s[x + y])
						&&
						(
							(
								(s[x + y] == '{' && ++m_brace_level)
								|| 		
								(s[x + y] == '}' && (m_brace_level-- || 1))
							) 
							|| 1
						)
					;	
						(s[x + y] == '}' && m_brace_level < 0)
						&&
						!(body[y] = 0)
					;>
'
	body='
	char	*o;


	
	asprintf(&o, "%s\n%s(%s%s ^(typeof(%s(%s%s 0)) %s) { %s });\n}",
		cat (prev), cat(name), cat(args), strlen(cat(args)) ? "," : "", cat(name), cat(args), strlen(cat(args)) ? "," : "",  lastword(cat(assignation)), cat(body));

	return (o);
']
961:	int
962:	bar
963:	(
964:	int
965:	p
966:	,
967:	void
968:	(
969:	^ptr
970:	)
971:	(
972:	int
973:	k
974:	)
975:	)
976:	{
977:	ptr
978:	(
979:	21
980:	)
981:	;
982:	return
983:	(
984:	0
985:	)
986:	;
987:	}
988:	int
989:	foo
990:	(
991:	int
992:	p
993:	,
994:	char
995:	c
996:	,
997:	void
998:	(
999:	^ptr
1000:	)
1001:	(
1002:	int
1003:	k
1004:	)
1005:	)
1006:	{
1007:	ptr
1008:	(
1009:	42
1010:	)
1011:	;
1012:	return
1013:	(
1014:	0
1015:	)
1016:	;
1017:	}
1018:	int
1019:	main
main begins at 1018
1020:	(
1021:	int
1022:	ac
1023:	,
1024:	char
1025:	*
1026:	*
1027:	av
1028:	)
1029:	{
1030:	printf
1031:	(
1032:	"
1033:	Hello
1034:	 
1035:	bb
1036:	!
1037:	 
1038:	Hallo
1039:	 
1040:	joe
1041:	 
1042:	10101
1043:	;
1044:	 
1045:	Hallo
1046:	 
1047:	ddd
1048:	;
1049:	"
1050:	)
1051:	;
1052:	{
1053:	auto
1054:	i
1055:	=
1056:	await
1057:	bar
1058:	(
1059:	10
1060:	)
1061:	;
1062:	printf
1063:	(
1064:	"
1065:	a
1066:	:
1067:	 
1068:	%i
1069:	\
1070:	n
1071:	"
1072:	,
1073:	i
1074:	)
1075:	;
1076:	auto
1077:	z
1078:	=
1079:	await
1080:	foo
1081:	(
1082:	21
1083:	,
1084:	'
1085:	c
1086:	'
1087:	)
1088:	;
1089:	printf
1090:	(
1091:	"
1092:	b
1093:	:
1094:	 
1095:	%i
1096:	\
1097:	n
1098:	"
1099:	,
1100:	z
1101:	)
1102:	;
1103:	}
1104:	return
1105:	(
1106:	0
1107:	)
1108:	;
1109:	}
pattern=
	< s[x+y] == 0 ; 0 ;>
 - body=
	return (cat("!! "));

pattern=
	<s[x + y] == "Hello "[y]				;	y == 5;>
		<(test2[y] = s[x + y]) && y < 5		;	s[x + y] == "!"[0]	&& !(test2[y] = 0);>
 - body=
	m_state_test += 1;
	return(cat("Good night dear ", test2, "."));

pattern=
	<
		(prev[0] = s[x])
		&&
		(
			s[x] == '{'
			||
			s[x] == semicolon
		)
		;
		(
			!(prev[1] = 0)
		)
	;>
	<
		(assignation[y] = s[x + y])
		&& 
		(
			s[x + y] != '{' 
			&& 
			s[x + y] != semicolon)
		;
		(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1)))
		&&
		!(assignation[y] = 0)
	;>
	<x
	; 
	!isspace(s[x + y]) && (--x || 1);>
	<s[x + y] == "await"[y]							; 	y == 4;>
		<(name[y] = s[x + y]) && y < 8 && s[x + y]	
		;	
		s[x + y] == '(' 
		&&
		!(
			(name[y] = 0)
			||
			(m_parenthesis_level = 0)
		)
		;>
				<(args[y] = s[x + y]) 
				&&
				(((s[x + y] == '(')
				&&
				++m_parenthesis_level) || 1)
				;
					(
						s[x + y] == ')'
						&&
						!(m_parenthesis_level < 0)
					)
					&& 
					!(
						(args[y] = 0) 
						||
						(m_brace_level = 0)
					)
				;>
					<(body[y] = s[x + y])
						&&
						(
							(
								(s[x + y] == '{' && ++m_brace_level)
								|| 		
								(s[x + y] == '}' && (m_brace_level-- || 1))
							) 
							|| 1
						)
					;	
						(s[x + y] == '}' && m_brace_level < 0)
						&&
						!(body[y] = 0)
					;>
 - body=
	char	*o;


	
	asprintf(&o, "%s\n%s(%s%s ^(typeof(%s(%s%s 0)) %s) { %s });\n}",
		cat (prev), cat(name), cat(args), strlen(cat(args)) ? "," : "", cat(name), cat(args), strlen(cat(args)) ? "," : "",  lastword(cat(assignation)), cat(body));

	return (o);

__________
file .//./build/spec-mvp.ce-compiler.c generated!
cc -g -I./ft_cedille_spec ./build/spec-mvp.ce-compiler.c -o \
			./build/spec-mvp.ce-compiler
valgrind --leak-check=full --show-leak-kinds=all ./build/spec-mvp.ce-compiler\
			./build/spec-mvp.ce .a.txt
out_file=.a.txt fd=3
source_file=./build/spec-mvp.ce fd=4
( !(prev[1] = 0) ) succeed macro_2 122!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 122!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 122!
( !(prev[1] = 0) ) succeed macro_2 151!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 151!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 151!
( !(prev[1] = 0) ) succeed macro_2 182!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 182!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 182!
( !(prev[1] = 0) ) succeed macro_2 217!
( !(prev[1] = 0) ) succeed macro_2 239!
( !(prev[1] = 0) ) succeed macro_2 252!
( !(prev[1] = 0) ) succeed macro_2 277!
( !(prev[1] = 0) ) succeed macro_2 290!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 290!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 290!
y == 5 succeed macro_1 334!
( !(prev[1] = 0) ) succeed macro_2 348!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 348!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 348!
( !(prev[1] = 0) ) succeed macro_2 356!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 356!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 356!
( !(prev[1] = 0) ) succeed macro_2 394!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 394!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 394!
( !(prev[1] = 0) ) succeed macro_2 433!
( !(prev[1] = 0) ) succeed macro_2 438!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 438!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 438!
( !(prev[1] = 0) ) succeed macro_2 458!
( !(prev[1] = 0) ) succeed macro_2 504!
( !(prev[1] = 0) ) succeed macro_2 540!
( !(prev[1] = 0) ) succeed macro_2 548!
( !(prev[1] = 0) ) succeed macro_2 558!
( !(prev[1] = 0) ) succeed macro_2 593!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 593!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 593!
( !(prev[1] = 0) ) succeed macro_2 605!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 605!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 605!
( !(prev[1] = 0) ) succeed macro_2 616!
( !(prev[1] = 0) ) succeed macro_2 655!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 655!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 655!
( !(prev[1] = 0) ) succeed macro_2 665!
( !(prev[1] = 0) ) succeed macro_2 699!
( !(prev[1] = 0) ) succeed macro_2 712!
( !(prev[1] = 0) ) succeed macro_2 750!
( !(prev[1] = 0) ) succeed macro_2 768!
( !(prev[1] = 0) ) succeed macro_2 777!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 777!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 777!
( !(prev[1] = 0) ) succeed macro_2 786!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 786!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 786!
( !(prev[1] = 0) ) succeed macro_2 813!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 813!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 813!
( !(prev[1] = 0) ) succeed macro_2 863!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 863!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 863!
( !(prev[1] = 0) ) succeed macro_2 915!
( !(prev[1] = 0) ) succeed macro_2 934!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 934!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 934!
y == 4 succeed macro_2 934!
s[x + y] == '(' && !( (name[y] = 0) || (m_parenthesis_level = 0) ) succeed macro_2 934!
( s[x + y] == ')' && !(m_parenthesis_level < 0) ) && !( (args[y] = 0) || (m_brace_level = 0) ) succeed macro_2 934!
( !(prev[1] = 0) ) succeed macro_2 1083!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1083!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1083!
( !(prev[1] = 0) ) succeed macro_2 1119!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1119!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1119!
( !(prev[1] = 0) ) succeed macro_2 1148!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1148!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1148!
( !(prev[1] = 0) ) succeed macro_2 1210!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1210!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1210!
( !(prev[1] = 0) ) succeed macro_2 1249!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1249!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1249!
( !(prev[1] = 0) ) succeed macro_2 1361!
( !(prev[1] = 0) ) succeed macro_2 1369!
( !(prev[1] = 0) ) succeed macro_2 1405!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1405!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1405!
( !(prev[1] = 0) ) succeed macro_2 1439!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1439!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1439!
( !(prev[1] = 0) ) succeed macro_2 1448!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1448!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1448!
( !(prev[1] = 0) ) succeed macro_2 1499!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1499!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1499!
( !(prev[1] = 0) ) succeed macro_2 1589!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1589!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1589!
( !(prev[1] = 0) ) succeed macro_2 1694!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1694!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1694!
( !(prev[1] = 0) ) succeed macro_2 1858!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1858!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1858!
( !(prev[1] = 0) ) succeed macro_2 1936!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1936!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1936!
( !(prev[1] = 0) ) succeed macro_2 2060!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 2060!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 2060!
( !(prev[1] = 0) ) succeed macro_2 2143!
( !(prev[1] = 0) ) succeed macro_2 2148!
( !(prev[1] = 0) ) succeed macro_2 2158!
( !(prev[1] = 0) ) succeed macro_2 2216!
( !(prev[1] = 0) ) succeed macro_2 2223!
( !(prev[1] = 0) ) succeed macro_2 2387!
( !(prev[1] = 0) ) succeed macro_2 2401!
( !(prev[1] = 0) ) succeed macro_2 2446!
( !(prev[1] = 0) ) succeed macro_2 2456!
( !(prev[1] = 0) ) succeed macro_2 2469!
( !(prev[1] = 0) ) succeed macro_2 2524!
( !(prev[1] = 0) ) succeed macro_2 2534!
( !(prev[1] = 0) ) succeed macro_2 2547!
( !(prev[1] = 0) ) succeed macro_2 2580!
y == 5 succeed macro_1 2592!
s[x + y] == "!"[0] && !(test2[y] = 0) succeed macro_1 2592!
1 macro applied [id=macro_0 i=2592 x=2601 on=Hello bb!].
( !(prev[1] = 0) ) succeed macro_2 2617!
( !(prev[1] = 0) ) succeed macro_2 2628!
( !(prev[1] = 0) ) succeed macro_2 2631!
( !(prev[1] = 0) ) succeed macro_2 2635!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 2635!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 2635!
y == 4 succeed macro_2 2635!
s[x + y] == '(' && !( (name[y] = 0) || (m_parenthesis_level = 0) ) succeed macro_2 2635!
( s[x + y] == ')' && !(m_parenthesis_level < 0) ) && !( (args[y] = 0) || (m_brace_level = 0) ) succeed macro_2 2635!
(s[x + y] == '}' && m_brace_level < 0) && !(body[y] = 0) succeed macro_2 2635!
1 macro applied [id=macro_1 i=2635 x=2744 on={
		auto i = await	bar(10);
		printf("a: %i\n", i);
		auto z = await	foo(21, 'c');
		printf("b: %i\n", z);
	}].
( !(prev[1] = 0) ) succeed macro_2 2756!
cp .a.txt ./build/spec-mvp.ce
((cmp .a.txt .b.txt) || (make spec-mvp.ce))
cc  -g 	compiler.c \
			get_next_linev2/get_next_line.c\
			get_next_linev2/get_next_line_utils.c\
		-o รงc
mkdir -p `dirname ./build/spec-mvp.ce`
touch .a.txt
cp .a.txt .b.txt
touch .b.txt
echo "oka"
oka
cp -n "ft_cedille_spec/spec-mvp.รง" "./build/spec-mvp.ce" || echo ""

valgrind --leak-check=full --show-leak-kinds=all ./รงc -I./ft_cedille_spec ./build/spec-mvp.ce -e -compiler.c -o ./
output path	: ./
output sufix	: -compiler.c
includes[]	: /usr/include
includes[]	: /usr/local/include
includes[]	: ./ft_cedille_spec
sources[]	: ./build/spec-mvp.ce
__________
#parsing: ./build/spec-mvp.ce
0:	#
1:	import
2:	"
3:	รง
4:	"
__________
#parsing: รง
-- parse(รง) returned 4242
__________
#parsing: /usr/include/รง
-- parse(/usr/include/รง) returned 4242
__________
#parsing: /usr/local/include/รง
-- parse(/usr/local/include/รง) returned 4242
__________
#parsing: ./ft_cedille_spec/รง
0:	#
1:	ifndef
2:	FT_CEDILLE_H
3:	#
4:	define
5:	FT_CEDILLE_H
6:	#
7:	define
8:	TOKENPASTE
9:	(
10:	x
11:	,
12:	y
13:	)
14:	x
15:	#
16:	#
17:	y
18:	#
19:	define
20:	TOKENPASTE2
21:	(
22:	x
23:	,
24:	y
25:	)
26:	TOKENPASTE
27:	(
28:	x
29:	,
30:	y
31:	)
32:	#
33:	define
34:	rule
35:	(
36:	.
37:	.
38:	.
39:	)
40:	TOKENPASTE2
41:	(
42:	char
43:	*
44:	r_
45:	,
46:	__LINE__
47:	)
48:	(
49:	int
50:	i
51:	,
52:	int
53:	x
54:	,
55:	char
56:	*
57:	s
58:	)
59:	#
60:	define
61:	macro
62:	#
63:	define
64:	cat
65:	(
66:	.
67:	.
68:	.
69:	)
70:	"
71:	"
72:	#
73:	endif
__________
5:	#
6:	import
7:	"
8:	spec
9:	-
10:	mvp2
11:	.
12:	รง
13:	"
__________
#parsing: spec-mvp2.รง
-- parse(spec-mvp2.รง) returned 4242
__________
#parsing: /usr/include/spec-mvp2.รง
-- parse(/usr/include/spec-mvp2.รง) returned 4242
__________
#parsing: /usr/local/include/spec-mvp2.รง
-- parse(/usr/local/include/spec-mvp2.รง) returned 4242
__________
#parsing: ./ft_cedille_spec/spec-mvp2.รง
0:	#
1:	import
2:	"
3:	รง
4:	"
[1mรง:1:1: [31merror: [0m[1mFile 'รง' already included !
[0m
5:	#
6:	define
7:	semicolon
8:	'
9:	;
10:	'
11:	macro
12:	int
13:	g
14:	(
15:	int
16:	z
17:	)
18:	{
19:	return
20:	z
21:	;
22:	}
23:	macro
24:	rule
25:	(
26:	<
27:	s
28:	[
29:	x
30:	+
31:	y
32:	]
33:	=
34:	=
35:	0
36:	;
37:	0
38:	;
39:	>
40:	)
41:	{
42:	return
43:	(
44:	cat
45:	(
46:	"
47:	!
48:	!
49:	 
50:	"
51:	)
52:	)
53:	;
54:	}
Macro pattern[pattern='
	< s[x+y] == 0 ; 0 ;>
'
	body='
	return (cat("!! "));
']
__________
14:	#
15:	include
16:	"
17:	stdio
18:	.
19:	h
20:	"
21:	#
22:	include
23:	"
24:	string
25:	.
26:	h
27:	"
28:	#
29:	include
30:	<
31:	ctype
32:	.
33:	h
34:	>
35:	macro
36:	int
37:	m_state_test
38:	=
39:	0
40:	;
41:	macro
42:	int
43:	m_brace_level
44:	=
45:	0
46:	;
47:	macro
48:	int
49:	m_bracket_level
50:	=
51:	0
52:	;
53:	macro
54:	int
55:	m_parenthesis_level
56:	=
57:	0
58:	;
59:	macro
60:	int
61:	f
62:	(
63:	int
64:	x
65:	)
66:	{
67:	return
68:	(
69:	x
70:	)
71:	;
72:	}
73:	/
74:	*
75:	

76:		
77:	<
78:	continue
79:	 
80:	while
81:	 
82:	;
83:	 
84:	succeed
85:	 
86:	on
87:	 
88:	;
89:	>
90:	

91:	*
92:	/
93:	/
94:	/
95:	 
96:	test
97:	

98:	macro
99:	rule
100:	(
101:	<
102:	s
103:	[
104:	x
105:	+
106:	y
107:	]
108:	=
109:	=
110:	"
111:	Hello
112:	 
113:	"
114:	[
115:	y
116:	]
117:	;
118:	y
119:	=
120:	=
121:	5
122:	;
123:	>
124:	<
125:	(
126:	test2
127:	[
128:	y
129:	]
130:	=
131:	s
132:	[
133:	x
134:	+
135:	y
136:	]
137:	)
138:	&&
139:	y
140:	<
141:	5
142:	;
143:	s
144:	[
145:	x
146:	+
147:	y
148:	]
149:	=
150:	=
151:	"
152:	!
153:	"
154:	[
155:	0
156:	]
157:	&&
158:	!
159:	(
160:	test2
161:	[
162:	y
163:	]
164:	=
165:	0
166:	)
167:	;
168:	>
169:	)
170:	{
171:	m_state_test
172:	+
173:	=
174:	1
175:	;
176:	return
177:	(
178:	cat
179:	(
180:	"
181:	Good
182:	 
183:	night
184:	 
185:	dear
186:	 
187:	"
188:	,
189:	test2
190:	,
191:	"
192:	.
193:	"
194:	)
195:	)
196:	;
197:	}
Macro pattern[pattern='
	<s[x + y] == "Hello "[y]				;	y == 5;>
		<(test2[y] = s[x + y]) && y < 5		;	s[x + y] == "!"[0]	&& !(test2[y] = 0);>
'
	body='
	m_state_test += 1;
	return(cat("Good night dear ", test2, "."));
']
198:	macro
199:	char
200:	*
201:	trim
202:	(
203:	char
204:	*
205:	str
206:	)
207:	{
208:	int
209:	i
210:	;
211:	char
212:	*
213:	o
214:	;
215:	while
216:	(
217:	*
218:	str
219:	&&
220:	isspace
221:	(
222:	*
223:	str
224:	)
225:	)
226:	{
227:	str
228:	+
229:	=
230:	1
231:	;
232:	}
233:	i
234:	=
235:	0
236:	;
237:	while
238:	(
239:	str
240:	[
241:	i
242:	]
243:	&&
244:	!
245:	isspace
246:	(
247:	str
248:	[
249:	i
250:	]
251:	)
252:	)
253:	{
254:	i
255:	+
256:	=
257:	1
258:	;
259:	}
260:	asprintf
261:	(
262:	&o
263:	,
264:	"
265:	%
266:	.
267:	*
268:	s
269:	"
270:	,
271:	i
272:	,
273:	str
274:	)
275:	;
276:	return
277:	(
278:	o
279:	)
280:	;
281:	}
282:	macro
283:	char
284:	*
285:	lastword
286:	(
287:	char
288:	*
289:	str
290:	)
291:	{
292:	char
293:	*
294:	lastspace
295:	;
296:	int
297:	i
298:	;
299:	i
300:	=
301:	0
302:	;
303:	while
304:	(
305:	str
306:	[
307:	i
308:	]
309:	)
310:	i
311:	+
312:	=
313:	1
314:	;
315:	while
316:	(
317:	(
318:	i
319:	-
320:	1
321:	)
322:	&&
323:	isspace
324:	(
325:	str
326:	[
327:	i
328:	-
329:	1
330:	]
331:	)
332:	)
333:	i
334:	-
335:	=
336:	1
337:	;
338:	while
339:	(
340:	(
341:	i
342:	-
343:	1
344:	)
345:	&&
346:	!
347:	isspace
348:	(
349:	str
350:	[
351:	i
352:	-
353:	1
354:	]
355:	)
356:	)
357:	i
358:	-
359:	=
360:	1
361:	;
362:	return
363:	(
364:	str
365:	+
366:	i
367:	)
368:	;
369:	}
370:	/
371:	*
372:	 
373:	TODO
374:	:
375:	 
376:	deeper
377:	 
378:	parse
379:	 
380:	-
381:	 
382:	f
383:	(
384:	await
385:	 
386:	g
387:	(
388:	.
389:	.
390:	.
391:	)
392:	[
393:	await
394:	 
395:	h
396:	(
397:	.
398:	.
399:	.
400:	)
401:	 
402:	+
403:	 
404:	await
405:	 
406:	i
407:	(
408:	.
409:	.
410:	.
411:	)
412:	]
413:	)
414:	 
415:	*
416:	/
417:	#
418:	define
419:	await
420:	macro
421:	rule
422:	(
423:	<
424:	(
425:	prev
426:	[
427:	0
428:	]
429:	=
430:	s
431:	[
432:	x
433:	]
434:	)
435:	&&
436:	(
437:	s
438:	[
439:	x
440:	]
441:	=
442:	=
443:	'
444:	{
445:	'
446:	||
447:	s
448:	[
449:	x
450:	]
451:	=
452:	=
453:	semicolon
454:	)
455:	;
456:	(
457:	!
458:	(
459:	prev
460:	[
461:	1
462:	]
463:	=
464:	0
465:	)
466:	)
467:	;
468:	>
469:	<
470:	(
471:	assignation
472:	[
473:	y
474:	]
475:	=
476:	s
477:	[
478:	x
479:	+
480:	y
481:	]
482:	)
483:	&&
484:	(
485:	s
486:	[
487:	x
488:	+
489:	y
490:	]
491:	!
492:	=
493:	'
494:	{
495:	'
496:	&&
497:	s
498:	[
499:	x
500:	+
501:	y
502:	]
503:	!
504:	=
505:	semicolon
506:	)
507:	;
508:	(
509:	s
510:	[
511:	x
512:	+
513:	y
514:	]
515:	=
516:	=
517:	'
518:	=
519:	'
520:	||
521:	(
522:	(
523:	s
524:	[
525:	x
526:	+
527:	y
528:	]
529:	=
530:	=
531:	'
532:	a
533:	'
534:	&&
535:	s
536:	[
537:	x
538:	+
539:	y
540:	+
541:	1
542:	]
543:	=
544:	=
545:	'
546:	w
547:	'
548:	)
549:	&&
550:	(
551:	-
552:	-
553:	x
554:	||
555:	1
556:	)
557:	)
558:	)
559:	&&
560:	!
561:	(
562:	assignation
563:	[
564:	y
565:	]
566:	=
567:	0
568:	)
569:	;
570:	>
571:	<
572:	x
573:	;
574:	!
575:	isspace
576:	(
577:	s
578:	[
579:	x
580:	+
581:	y
582:	]
583:	)
584:	&&
585:	(
586:	-
587:	-
588:	x
589:	||
590:	1
591:	)
592:	;
593:	>
594:	<
595:	s
596:	[
597:	x
598:	+
599:	y
600:	]
601:	=
602:	=
603:	"
604:	await
605:	"
606:	[
607:	y
608:	]
609:	;
610:	y
611:	=
612:	=
613:	4
614:	;
615:	>
616:	<
617:	(
618:	name
619:	[
620:	y
621:	]
622:	=
623:	s
624:	[
625:	x
626:	+
627:	y
628:	]
629:	)
630:	&&
631:	y
632:	<
633:	8
634:	&&
635:	s
636:	[
637:	x
638:	+
639:	y
640:	]
641:	;
642:	s
643:	[
644:	x
645:	+
646:	y
647:	]
648:	=
649:	=
650:	'
651:	(
652:	'
653:	&&
654:	!
655:	(
656:	(
657:	name
658:	[
659:	y
660:	]
661:	=
662:	0
663:	)
664:	||
665:	(
666:	m_parenthesis_level
667:	=
668:	0
669:	)
670:	)
671:	;
672:	>
673:	<
674:	(
675:	args
676:	[
677:	y
678:	]
679:	=
680:	s
681:	[
682:	x
683:	+
684:	y
685:	]
686:	)
687:	&&
688:	(
689:	(
690:	(
691:	s
692:	[
693:	x
694:	+
695:	y
696:	]
697:	=
698:	=
699:	'
700:	(
701:	'
702:	)
703:	&&
704:	+
705:	+
706:	m_parenthesis_level
707:	)
708:	||
709:	1
710:	)
711:	;
712:	(
713:	s
714:	[
715:	x
716:	+
717:	y
718:	]
719:	=
720:	=
721:	'
722:	)
723:	'
724:	&&
725:	!
726:	(
727:	m_parenthesis_level
728:	<
729:	0
730:	)
731:	)
732:	&&
733:	!
734:	(
735:	(
736:	args
737:	[
738:	y
739:	]
740:	=
741:	0
742:	)
743:	||
744:	(
745:	m_brace_level
746:	=
747:	0
748:	)
749:	)
750:	;
751:	>
752:	<
753:	(
754:	body
755:	[
756:	y
757:	]
758:	=
759:	s
760:	[
761:	x
762:	+
763:	y
764:	]
765:	)
766:	&&
767:	(
768:	(
769:	(
770:	s
771:	[
772:	x
773:	+
774:	y
775:	]
776:	=
777:	=
778:	'
779:	{
780:	'
781:	&&
782:	+
783:	+
784:	m_brace_level
785:	)
786:	||
787:	(
788:	s
789:	[
790:	x
791:	+
792:	y
793:	]
794:	=
795:	=
796:	'
797:	}
798:	'
799:	&&
800:	(
801:	m_brace_level
802:	-
803:	-
804:	||
805:	1
806:	)
807:	)
808:	)
809:	||
810:	1
811:	)
812:	;
813:	(
814:	s
815:	[
816:	x
817:	+
818:	y
819:	]
820:	=
821:	=
822:	'
823:	}
824:	'
825:	&&
826:	m_brace_level
827:	<
828:	0
829:	)
830:	&&
831:	!
832:	(
833:	body
834:	[
835:	y
836:	]
837:	=
838:	0
839:	)
840:	;
841:	>
842:	)
843:	{
844:	char
845:	*
846:	o
847:	;
848:	asprintf
849:	(
850:	&o
851:	,
852:	"
853:	%s
854:	\
855:	n%s
856:	(
857:	%s%s
858:	 
859:	^
860:	(
861:	typeof
862:	(
863:	%s
864:	(
865:	%s%s
866:	 
867:	0
868:	)
869:	)
870:	 
871:	%s
872:	)
873:	 
874:	{
875:	 
876:	%s
877:	 
878:	}
879:	)
880:	;
881:	\
882:	n
883:	}
884:	"
885:	,
886:	cat
887:	(
888:	prev
889:	)
890:	,
891:	cat
892:	(
893:	name
894:	)
895:	,
896:	cat
897:	(
898:	args
899:	)
900:	,
901:	strlen
902:	(
903:	cat
904:	(
905:	args
906:	)
907:	)
908:	?
909:	"
910:	,
911:	"
912:	:
913:	"
914:	"
915:	,
916:	cat
917:	(
918:	name
919:	)
920:	,
921:	cat
922:	(
923:	args
924:	)
925:	,
926:	strlen
927:	(
928:	cat
929:	(
930:	args
931:	)
932:	)
933:	?
934:	"
935:	,
936:	"
937:	:
938:	"
939:	"
940:	,
941:	lastword
942:	(
943:	cat
944:	(
945:	assignation
946:	)
947:	)
948:	,
949:	cat
950:	(
951:	body
952:	)
953:	)
954:	;
955:	return
956:	(
957:	o
958:	)
959:	;
960:	}
Macro pattern[pattern='
	<
		(prev[0] = s[x])
		&&
		(
			s[x] == '{'
			||
			s[x] == semicolon
		)
		;
		(
			!(prev[1] = 0)
		)
	;>
	<
		(assignation[y] = s[x + y])
		&& 
		(
			s[x + y] != '{' 
			&& 
			s[x + y] != semicolon)
		;
		(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1)))
		&&
		!(assignation[y] = 0)
	;>
	<x
	; 
	!isspace(s[x + y]) && (--x || 1);>
	<s[x + y] == "await"[y]							; 	y == 4;>
		<(name[y] = s[x + y]) && y < 8 && s[x + y]	
		;	
		s[x + y] == '(' 
		&&
		!(
			(name[y] = 0)
			||
			(m_parenthesis_level = 0)
		)
		;>
				<(args[y] = s[x + y]) 
				&&
				(((s[x + y] == '(')
				&&
				++m_parenthesis_level) || 1)
				;
					(
						s[x + y] == ')'
						&&
						!(m_parenthesis_level < 0)
					)
					&& 
					!(
						(args[y] = 0) 
						||
						(m_brace_level = 0)
					)
				;>
					<(body[y] = s[x + y])
						&&
						(
							(
								(s[x + y] == '{' && ++m_brace_level)
								|| 		
								(s[x + y] == '}' && (m_brace_level-- || 1))
							) 
							|| 1
						)
					;	
						(s[x + y] == '}' && m_brace_level < 0)
						&&
						!(body[y] = 0)
					;>
'
	body='
	char	*o;


	
	asprintf(&o, "%s\n%s(%s%s ^(typeof(%s(%s%s 0)) %s) { %s });\n}",
		cat (prev), cat(name), cat(args), strlen(cat(args)) ? "," : "", cat(name), cat(args), strlen(cat(args)) ? "," : "",  lastword(cat(assignation)), cat(body));

	return (o);
']
961:	int
962:	bar
963:	(
964:	int
965:	p
966:	,
967:	void
968:	(
969:	^ptr
970:	)
971:	(
972:	int
973:	k
974:	)
975:	)
976:	{
977:	ptr
978:	(
979:	21
980:	)
981:	;
982:	return
983:	(
984:	0
985:	)
986:	;
987:	}
988:	int
989:	foo
990:	(
991:	int
992:	p
993:	,
994:	char
995:	c
996:	,
997:	void
998:	(
999:	^ptr
1000:	)
1001:	(
1002:	int
1003:	k
1004:	)
1005:	)
1006:	{
1007:	ptr
1008:	(
1009:	42
1010:	)
1011:	;
1012:	return
1013:	(
1014:	0
1015:	)
1016:	;
1017:	}
1018:	int
1019:	main
main begins at 1018
1020:	(
1021:	int
1022:	ac
1023:	,
1024:	char
1025:	*
1026:	*
1027:	av
1028:	)
1029:	{
1030:	printf
1031:	(
1032:	"
1033:	Good
1034:	 
1035:	night
1036:	 
1037:	dear
1038:	 
1039:	bb
1040:	.
1041:	 
1042:	Hallo
1043:	 
1044:	joe
1045:	 
1046:	10101
1047:	;
1048:	 
1049:	Hallo
1050:	 
1051:	ddd
1052:	;
1053:	"
1054:	)
1055:	;
1056:	{
1057:	bar
1058:	(
1059:	10
1060:	,
1061:	^
1062:	(
1063:	typeof
1064:	(
1065:	bar
1066:	(
1067:	10
1068:	,
1069:	0
1070:	)
1071:	)
1072:	i
1073:	)
1074:	{
1075:	;
1076:	printf
1077:	(
1078:	"
1079:	a
1080:	:
1081:	 
1082:	%i
1083:	\
1084:	n
1085:	"
1086:	,
1087:	i
1088:	)
1089:	;
1090:	auto
1091:	z
1092:	=
1093:	await
1094:	foo
1095:	(
1096:	21
1097:	,
1098:	'
1099:	c
1100:	'
1101:	)
1102:	;
1103:	printf
1104:	(
1105:	"
1106:	b
1107:	:
1108:	 
1109:	%i
1110:	\
1111:	n
1112:	"
1113:	,
1114:	z
1115:	)
1116:	;
1117:	}
1118:	)
1119:	;
1120:	}
1121:	return
1122:	(
1123:	0
1124:	)
1125:	;
1126:	}
pattern=
	< s[x+y] == 0 ; 0 ;>
 - body=
	return (cat("!! "));

pattern=
	<s[x + y] == "Hello "[y]				;	y == 5;>
		<(test2[y] = s[x + y]) && y < 5		;	s[x + y] == "!"[0]	&& !(test2[y] = 0);>
 - body=
	m_state_test += 1;
	return(cat("Good night dear ", test2, "."));

pattern=
	<
		(prev[0] = s[x])
		&&
		(
			s[x] == '{'
			||
			s[x] == semicolon
		)
		;
		(
			!(prev[1] = 0)
		)
	;>
	<
		(assignation[y] = s[x + y])
		&& 
		(
			s[x + y] != '{' 
			&& 
			s[x + y] != semicolon)
		;
		(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1)))
		&&
		!(assignation[y] = 0)
	;>
	<x
	; 
	!isspace(s[x + y]) && (--x || 1);>
	<s[x + y] == "await"[y]							; 	y == 4;>
		<(name[y] = s[x + y]) && y < 8 && s[x + y]	
		;	
		s[x + y] == '(' 
		&&
		!(
			(name[y] = 0)
			||
			(m_parenthesis_level = 0)
		)
		;>
				<(args[y] = s[x + y]) 
				&&
				(((s[x + y] == '(')
				&&
				++m_parenthesis_level) || 1)
				;
					(
						s[x + y] == ')'
						&&
						!(m_parenthesis_level < 0)
					)
					&& 
					!(
						(args[y] = 0) 
						||
						(m_brace_level = 0)
					)
				;>
					<(body[y] = s[x + y])
						&&
						(
							(
								(s[x + y] == '{' && ++m_brace_level)
								|| 		
								(s[x + y] == '}' && (m_brace_level-- || 1))
							) 
							|| 1
						)
					;	
						(s[x + y] == '}' && m_brace_level < 0)
						&&
						!(body[y] = 0)
					;>
 - body=
	char	*o;


	
	asprintf(&o, "%s\n%s(%s%s ^(typeof(%s(%s%s 0)) %s) { %s });\n}",
		cat (prev), cat(name), cat(args), strlen(cat(args)) ? "," : "", cat(name), cat(args), strlen(cat(args)) ? "," : "",  lastword(cat(assignation)), cat(body));

	return (o);

__________
file .//./build/spec-mvp.ce-compiler.c generated!
cc -g -I./ft_cedille_spec ./build/spec-mvp.ce-compiler.c -o \
			./build/spec-mvp.ce-compiler
valgrind --leak-check=full --show-leak-kinds=all ./build/spec-mvp.ce-compiler\
			./build/spec-mvp.ce .a.txt
out_file=.a.txt fd=3
source_file=./build/spec-mvp.ce fd=4
( !(prev[1] = 0) ) succeed macro_2 122!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 122!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 122!
( !(prev[1] = 0) ) succeed macro_2 151!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 151!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 151!
( !(prev[1] = 0) ) succeed macro_2 182!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 182!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 182!
( !(prev[1] = 0) ) succeed macro_2 217!
( !(prev[1] = 0) ) succeed macro_2 239!
( !(prev[1] = 0) ) succeed macro_2 252!
( !(prev[1] = 0) ) succeed macro_2 277!
( !(prev[1] = 0) ) succeed macro_2 290!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 290!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 290!
y == 5 succeed macro_1 334!
( !(prev[1] = 0) ) succeed macro_2 348!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 348!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 348!
( !(prev[1] = 0) ) succeed macro_2 356!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 356!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 356!
( !(prev[1] = 0) ) succeed macro_2 394!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 394!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 394!
( !(prev[1] = 0) ) succeed macro_2 433!
( !(prev[1] = 0) ) succeed macro_2 438!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 438!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 438!
( !(prev[1] = 0) ) succeed macro_2 458!
( !(prev[1] = 0) ) succeed macro_2 504!
( !(prev[1] = 0) ) succeed macro_2 540!
( !(prev[1] = 0) ) succeed macro_2 548!
( !(prev[1] = 0) ) succeed macro_2 558!
( !(prev[1] = 0) ) succeed macro_2 593!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 593!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 593!
( !(prev[1] = 0) ) succeed macro_2 605!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 605!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 605!
( !(prev[1] = 0) ) succeed macro_2 616!
( !(prev[1] = 0) ) succeed macro_2 655!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 655!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 655!
( !(prev[1] = 0) ) succeed macro_2 665!
( !(prev[1] = 0) ) succeed macro_2 699!
( !(prev[1] = 0) ) succeed macro_2 712!
( !(prev[1] = 0) ) succeed macro_2 750!
( !(prev[1] = 0) ) succeed macro_2 768!
( !(prev[1] = 0) ) succeed macro_2 777!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 777!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 777!
( !(prev[1] = 0) ) succeed macro_2 786!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 786!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 786!
( !(prev[1] = 0) ) succeed macro_2 813!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 813!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 813!
( !(prev[1] = 0) ) succeed macro_2 863!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 863!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 863!
( !(prev[1] = 0) ) succeed macro_2 915!
( !(prev[1] = 0) ) succeed macro_2 934!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 934!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 934!
y == 4 succeed macro_2 934!
s[x + y] == '(' && !( (name[y] = 0) || (m_parenthesis_level = 0) ) succeed macro_2 934!
( s[x + y] == ')' && !(m_parenthesis_level < 0) ) && !( (args[y] = 0) || (m_brace_level = 0) ) succeed macro_2 934!
( !(prev[1] = 0) ) succeed macro_2 1083!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1083!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1083!
( !(prev[1] = 0) ) succeed macro_2 1119!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1119!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1119!
( !(prev[1] = 0) ) succeed macro_2 1148!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1148!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1148!
( !(prev[1] = 0) ) succeed macro_2 1210!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1210!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1210!
( !(prev[1] = 0) ) succeed macro_2 1249!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1249!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1249!
( !(prev[1] = 0) ) succeed macro_2 1361!
( !(prev[1] = 0) ) succeed macro_2 1369!
( !(prev[1] = 0) ) succeed macro_2 1405!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1405!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1405!
( !(prev[1] = 0) ) succeed macro_2 1439!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1439!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1439!
( !(prev[1] = 0) ) succeed macro_2 1448!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1448!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1448!
( !(prev[1] = 0) ) succeed macro_2 1499!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1499!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1499!
( !(prev[1] = 0) ) succeed macro_2 1589!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1589!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1589!
( !(prev[1] = 0) ) succeed macro_2 1694!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1694!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1694!
( !(prev[1] = 0) ) succeed macro_2 1858!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1858!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1858!
( !(prev[1] = 0) ) succeed macro_2 1936!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1936!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1936!
( !(prev[1] = 0) ) succeed macro_2 2060!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 2060!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 2060!
( !(prev[1] = 0) ) succeed macro_2 2143!
( !(prev[1] = 0) ) succeed macro_2 2148!
( !(prev[1] = 0) ) succeed macro_2 2158!
( !(prev[1] = 0) ) succeed macro_2 2216!
( !(prev[1] = 0) ) succeed macro_2 2223!
( !(prev[1] = 0) ) succeed macro_2 2387!
( !(prev[1] = 0) ) succeed macro_2 2401!
( !(prev[1] = 0) ) succeed macro_2 2446!
( !(prev[1] = 0) ) succeed macro_2 2456!
( !(prev[1] = 0) ) succeed macro_2 2469!
( !(prev[1] = 0) ) succeed macro_2 2524!
( !(prev[1] = 0) ) succeed macro_2 2534!
( !(prev[1] = 0) ) succeed macro_2 2547!
( !(prev[1] = 0) ) succeed macro_2 2580!
( !(prev[1] = 0) ) succeed macro_2 2627!
( !(prev[1] = 0) ) succeed macro_2 2638!
( !(prev[1] = 0) ) succeed macro_2 2641!
( !(prev[1] = 0) ) succeed macro_2 2645!
( !(prev[1] = 0) ) succeed macro_2 2682!
( !(prev[1] = 0) ) succeed macro_2 2684!
( !(prev[1] = 0) ) succeed macro_2 2708!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 2708!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 2708!
y == 4 succeed macro_2 2708!
s[x + y] == '(' && !( (name[y] = 0) || (m_parenthesis_level = 0) ) succeed macro_2 2708!
( s[x + y] == ')' && !(m_parenthesis_level < 0) ) && !( (args[y] = 0) || (m_brace_level = 0) ) succeed macro_2 2708!
(s[x + y] == '}' && m_brace_level < 0) && !(body[y] = 0) succeed macro_2 2708!
1 macro applied [id=macro_1 i=2708 x=2768 on=;
		auto z = await	foo(21, 'c');
		printf("b: %i\n", z);
	 }].
( !(prev[1] = 0) ) succeed macro_2 2769!
( !(prev[1] = 0) ) succeed macro_2 2784!
cp .a.txt ./build/spec-mvp.ce
((cmp .a.txt .b.txt) || (make spec-mvp.ce))
.a.txt .b.txt differ: char 2712, line 184
cc  -g 	compiler.c \
			get_next_linev2/get_next_line.c\
			get_next_linev2/get_next_line_utils.c\
		-o รงc
mkdir -p `dirname ./build/spec-mvp.ce`
touch .a.txt
cp .a.txt .b.txt
touch .b.txt
echo "oka"
oka
cp -n "ft_cedille_spec/spec-mvp.รง" "./build/spec-mvp.ce" || echo ""

valgrind --leak-check=full --show-leak-kinds=all ./รงc -I./ft_cedille_spec ./build/spec-mvp.ce -e -compiler.c -o ./
output path	: ./
output sufix	: -compiler.c
includes[]	: /usr/include
includes[]	: /usr/local/include
includes[]	: ./ft_cedille_spec
sources[]	: ./build/spec-mvp.ce
__________
#parsing: ./build/spec-mvp.ce
0:	#
1:	import
2:	"
3:	รง
4:	"
__________
#parsing: รง
-- parse(รง) returned 4242
__________
#parsing: /usr/include/รง
-- parse(/usr/include/รง) returned 4242
__________
#parsing: /usr/local/include/รง
-- parse(/usr/local/include/รง) returned 4242
__________
#parsing: ./ft_cedille_spec/รง
0:	#
1:	ifndef
2:	FT_CEDILLE_H
3:	#
4:	define
5:	FT_CEDILLE_H
6:	#
7:	define
8:	TOKENPASTE
9:	(
10:	x
11:	,
12:	y
13:	)
14:	x
15:	#
16:	#
17:	y
18:	#
19:	define
20:	TOKENPASTE2
21:	(
22:	x
23:	,
24:	y
25:	)
26:	TOKENPASTE
27:	(
28:	x
29:	,
30:	y
31:	)
32:	#
33:	define
34:	rule
35:	(
36:	.
37:	.
38:	.
39:	)
40:	TOKENPASTE2
41:	(
42:	char
43:	*
44:	r_
45:	,
46:	__LINE__
47:	)
48:	(
49:	int
50:	i
51:	,
52:	int
53:	x
54:	,
55:	char
56:	*
57:	s
58:	)
59:	#
60:	define
61:	macro
62:	#
63:	define
64:	cat
65:	(
66:	.
67:	.
68:	.
69:	)
70:	"
71:	"
72:	#
73:	endif
__________
5:	#
6:	import
7:	"
8:	spec
9:	-
10:	mvp2
11:	.
12:	รง
13:	"
__________
#parsing: spec-mvp2.รง
-- parse(spec-mvp2.รง) returned 4242
__________
#parsing: /usr/include/spec-mvp2.รง
-- parse(/usr/include/spec-mvp2.รง) returned 4242
__________
#parsing: /usr/local/include/spec-mvp2.รง
-- parse(/usr/local/include/spec-mvp2.รง) returned 4242
__________
#parsing: ./ft_cedille_spec/spec-mvp2.รง
0:	#
1:	import
2:	"
3:	รง
4:	"
[1mรง:1:1: [31merror: [0m[1mFile 'รง' already included !
[0m
5:	#
6:	define
7:	semicolon
8:	'
9:	;
10:	'
11:	macro
12:	int
13:	g
14:	(
15:	int
16:	z
17:	)
18:	{
19:	return
20:	z
21:	;
22:	}
23:	macro
24:	rule
25:	(
26:	<
27:	s
28:	[
29:	x
30:	+
31:	y
32:	]
33:	=
34:	=
35:	0
36:	;
37:	0
38:	;
39:	>
40:	)
41:	{
42:	return
43:	(
44:	cat
45:	(
46:	"
47:	!
48:	!
49:	 
50:	"
51:	)
52:	)
53:	;
54:	}
Macro pattern[pattern='
	< s[x+y] == 0 ; 0 ;>
'
	body='
	return (cat("!! "));
']
__________
14:	#
15:	include
16:	"
17:	stdio
18:	.
19:	h
20:	"
21:	#
22:	include
23:	"
24:	string
25:	.
26:	h
27:	"
28:	#
29:	include
30:	<
31:	ctype
32:	.
33:	h
34:	>
35:	macro
36:	int
37:	m_state_test
38:	=
39:	0
40:	;
41:	macro
42:	int
43:	m_brace_level
44:	=
45:	0
46:	;
47:	macro
48:	int
49:	m_bracket_level
50:	=
51:	0
52:	;
53:	macro
54:	int
55:	m_parenthesis_level
56:	=
57:	0
58:	;
59:	macro
60:	int
61:	f
62:	(
63:	int
64:	x
65:	)
66:	{
67:	return
68:	(
69:	x
70:	)
71:	;
72:	}
73:	/
74:	*
75:	

76:		
77:	<
78:	continue
79:	 
80:	while
81:	 
82:	;
83:	 
84:	succeed
85:	 
86:	on
87:	 
88:	;
89:	>
90:	

91:	*
92:	/
93:	/
94:	/
95:	 
96:	test
97:	

98:	macro
99:	rule
100:	(
101:	<
102:	s
103:	[
104:	x
105:	+
106:	y
107:	]
108:	=
109:	=
110:	"
111:	Hello
112:	 
113:	"
114:	[
115:	y
116:	]
117:	;
118:	y
119:	=
120:	=
121:	5
122:	;
123:	>
124:	<
125:	(
126:	test2
127:	[
128:	y
129:	]
130:	=
131:	s
132:	[
133:	x
134:	+
135:	y
136:	]
137:	)
138:	&&
139:	y
140:	<
141:	5
142:	;
143:	s
144:	[
145:	x
146:	+
147:	y
148:	]
149:	=
150:	=
151:	"
152:	!
153:	"
154:	[
155:	0
156:	]
157:	&&
158:	!
159:	(
160:	test2
161:	[
162:	y
163:	]
164:	=
165:	0
166:	)
167:	;
168:	>
169:	)
170:	{
171:	m_state_test
172:	+
173:	=
174:	1
175:	;
176:	return
177:	(
178:	cat
179:	(
180:	"
181:	Good
182:	 
183:	night
184:	 
185:	dear
186:	 
187:	"
188:	,
189:	test2
190:	,
191:	"
192:	.
193:	"
194:	)
195:	)
196:	;
197:	}
Macro pattern[pattern='
	<s[x + y] == "Hello "[y]				;	y == 5;>
		<(test2[y] = s[x + y]) && y < 5		;	s[x + y] == "!"[0]	&& !(test2[y] = 0);>
'
	body='
	m_state_test += 1;
	return(cat("Good night dear ", test2, "."));
']
198:	macro
199:	char
200:	*
201:	trim
202:	(
203:	char
204:	*
205:	str
206:	)
207:	{
208:	int
209:	i
210:	;
211:	char
212:	*
213:	o
214:	;
215:	while
216:	(
217:	*
218:	str
219:	&&
220:	isspace
221:	(
222:	*
223:	str
224:	)
225:	)
226:	{
227:	str
228:	+
229:	=
230:	1
231:	;
232:	}
233:	i
234:	=
235:	0
236:	;
237:	while
238:	(
239:	str
240:	[
241:	i
242:	]
243:	&&
244:	!
245:	isspace
246:	(
247:	str
248:	[
249:	i
250:	]
251:	)
252:	)
253:	{
254:	i
255:	+
256:	=
257:	1
258:	;
259:	}
260:	asprintf
261:	(
262:	&o
263:	,
264:	"
265:	%
266:	.
267:	*
268:	s
269:	"
270:	,
271:	i
272:	,
273:	str
274:	)
275:	;
276:	return
277:	(
278:	o
279:	)
280:	;
281:	}
282:	macro
283:	char
284:	*
285:	lastword
286:	(
287:	char
288:	*
289:	str
290:	)
291:	{
292:	char
293:	*
294:	lastspace
295:	;
296:	int
297:	i
298:	;
299:	i
300:	=
301:	0
302:	;
303:	while
304:	(
305:	str
306:	[
307:	i
308:	]
309:	)
310:	i
311:	+
312:	=
313:	1
314:	;
315:	while
316:	(
317:	(
318:	i
319:	-
320:	1
321:	)
322:	&&
323:	isspace
324:	(
325:	str
326:	[
327:	i
328:	-
329:	1
330:	]
331:	)
332:	)
333:	i
334:	-
335:	=
336:	1
337:	;
338:	while
339:	(
340:	(
341:	i
342:	-
343:	1
344:	)
345:	&&
346:	!
347:	isspace
348:	(
349:	str
350:	[
351:	i
352:	-
353:	1
354:	]
355:	)
356:	)
357:	i
358:	-
359:	=
360:	1
361:	;
362:	return
363:	(
364:	str
365:	+
366:	i
367:	)
368:	;
369:	}
370:	/
371:	*
372:	 
373:	TODO
374:	:
375:	 
376:	deeper
377:	 
378:	parse
379:	 
380:	-
381:	 
382:	f
383:	(
384:	await
385:	 
386:	g
387:	(
388:	.
389:	.
390:	.
391:	)
392:	[
393:	await
394:	 
395:	h
396:	(
397:	.
398:	.
399:	.
400:	)
401:	 
402:	+
403:	 
404:	await
405:	 
406:	i
407:	(
408:	.
409:	.
410:	.
411:	)
412:	]
413:	)
414:	 
415:	*
416:	/
417:	#
418:	define
419:	await
420:	macro
421:	rule
422:	(
423:	<
424:	(
425:	prev
426:	[
427:	0
428:	]
429:	=
430:	s
431:	[
432:	x
433:	]
434:	)
435:	&&
436:	(
437:	s
438:	[
439:	x
440:	]
441:	=
442:	=
443:	'
444:	{
445:	'
446:	||
447:	s
448:	[
449:	x
450:	]
451:	=
452:	=
453:	semicolon
454:	)
455:	;
456:	(
457:	!
458:	(
459:	prev
460:	[
461:	1
462:	]
463:	=
464:	0
465:	)
466:	)
467:	;
468:	>
469:	<
470:	(
471:	assignation
472:	[
473:	y
474:	]
475:	=
476:	s
477:	[
478:	x
479:	+
480:	y
481:	]
482:	)
483:	&&
484:	(
485:	s
486:	[
487:	x
488:	+
489:	y
490:	]
491:	!
492:	=
493:	'
494:	{
495:	'
496:	&&
497:	s
498:	[
499:	x
500:	+
501:	y
502:	]
503:	!
504:	=
505:	semicolon
506:	)
507:	;
508:	(
509:	s
510:	[
511:	x
512:	+
513:	y
514:	]
515:	=
516:	=
517:	'
518:	=
519:	'
520:	||
521:	(
522:	(
523:	s
524:	[
525:	x
526:	+
527:	y
528:	]
529:	=
530:	=
531:	'
532:	a
533:	'
534:	&&
535:	s
536:	[
537:	x
538:	+
539:	y
540:	+
541:	1
542:	]
543:	=
544:	=
545:	'
546:	w
547:	'
548:	)
549:	&&
550:	(
551:	-
552:	-
553:	x
554:	||
555:	1
556:	)
557:	)
558:	)
559:	&&
560:	!
561:	(
562:	assignation
563:	[
564:	y
565:	]
566:	=
567:	0
568:	)
569:	;
570:	>
571:	<
572:	x
573:	;
574:	!
575:	isspace
576:	(
577:	s
578:	[
579:	x
580:	+
581:	y
582:	]
583:	)
584:	&&
585:	(
586:	-
587:	-
588:	x
589:	||
590:	1
591:	)
592:	;
593:	>
594:	<
595:	s
596:	[
597:	x
598:	+
599:	y
600:	]
601:	=
602:	=
603:	"
604:	await
605:	"
606:	[
607:	y
608:	]
609:	;
610:	y
611:	=
612:	=
613:	4
614:	;
615:	>
616:	<
617:	(
618:	name
619:	[
620:	y
621:	]
622:	=
623:	s
624:	[
625:	x
626:	+
627:	y
628:	]
629:	)
630:	&&
631:	y
632:	<
633:	8
634:	&&
635:	s
636:	[
637:	x
638:	+
639:	y
640:	]
641:	;
642:	s
643:	[
644:	x
645:	+
646:	y
647:	]
648:	=
649:	=
650:	'
651:	(
652:	'
653:	&&
654:	!
655:	(
656:	(
657:	name
658:	[
659:	y
660:	]
661:	=
662:	0
663:	)
664:	||
665:	(
666:	m_parenthesis_level
667:	=
668:	0
669:	)
670:	)
671:	;
672:	>
673:	<
674:	(
675:	args
676:	[
677:	y
678:	]
679:	=
680:	s
681:	[
682:	x
683:	+
684:	y
685:	]
686:	)
687:	&&
688:	(
689:	(
690:	(
691:	s
692:	[
693:	x
694:	+
695:	y
696:	]
697:	=
698:	=
699:	'
700:	(
701:	'
702:	)
703:	&&
704:	+
705:	+
706:	m_parenthesis_level
707:	)
708:	||
709:	1
710:	)
711:	;
712:	(
713:	s
714:	[
715:	x
716:	+
717:	y
718:	]
719:	=
720:	=
721:	'
722:	)
723:	'
724:	&&
725:	!
726:	(
727:	m_parenthesis_level
728:	<
729:	0
730:	)
731:	)
732:	&&
733:	!
734:	(
735:	(
736:	args
737:	[
738:	y
739:	]
740:	=
741:	0
742:	)
743:	||
744:	(
745:	m_brace_level
746:	=
747:	0
748:	)
749:	)
750:	;
751:	>
752:	<
753:	(
754:	body
755:	[
756:	y
757:	]
758:	=
759:	s
760:	[
761:	x
762:	+
763:	y
764:	]
765:	)
766:	&&
767:	(
768:	(
769:	(
770:	s
771:	[
772:	x
773:	+
774:	y
775:	]
776:	=
777:	=
778:	'
779:	{
780:	'
781:	&&
782:	+
783:	+
784:	m_brace_level
785:	)
786:	||
787:	(
788:	s
789:	[
790:	x
791:	+
792:	y
793:	]
794:	=
795:	=
796:	'
797:	}
798:	'
799:	&&
800:	(
801:	m_brace_level
802:	-
803:	-
804:	||
805:	1
806:	)
807:	)
808:	)
809:	||
810:	1
811:	)
812:	;
813:	(
814:	s
815:	[
816:	x
817:	+
818:	y
819:	]
820:	=
821:	=
822:	'
823:	}
824:	'
825:	&&
826:	m_brace_level
827:	<
828:	0
829:	)
830:	&&
831:	!
832:	(
833:	body
834:	[
835:	y
836:	]
837:	=
838:	0
839:	)
840:	;
841:	>
842:	)
843:	{
844:	char
845:	*
846:	o
847:	;
848:	asprintf
849:	(
850:	&o
851:	,
852:	"
853:	%s
854:	\
855:	n%s
856:	(
857:	%s%s
858:	 
859:	^
860:	(
861:	typeof
862:	(
863:	%s
864:	(
865:	%s%s
866:	 
867:	0
868:	)
869:	)
870:	 
871:	%s
872:	)
873:	 
874:	{
875:	 
876:	%s
877:	 
878:	}
879:	)
880:	;
881:	\
882:	n
883:	}
884:	"
885:	,
886:	cat
887:	(
888:	prev
889:	)
890:	,
891:	cat
892:	(
893:	name
894:	)
895:	,
896:	cat
897:	(
898:	args
899:	)
900:	,
901:	strlen
902:	(
903:	cat
904:	(
905:	args
906:	)
907:	)
908:	?
909:	"
910:	,
911:	"
912:	:
913:	"
914:	"
915:	,
916:	cat
917:	(
918:	name
919:	)
920:	,
921:	cat
922:	(
923:	args
924:	)
925:	,
926:	strlen
927:	(
928:	cat
929:	(
930:	args
931:	)
932:	)
933:	?
934:	"
935:	,
936:	"
937:	:
938:	"
939:	"
940:	,
941:	lastword
942:	(
943:	cat
944:	(
945:	assignation
946:	)
947:	)
948:	,
949:	cat
950:	(
951:	body
952:	)
953:	)
954:	;
955:	return
956:	(
957:	o
958:	)
959:	;
960:	}
Macro pattern[pattern='
	<
		(prev[0] = s[x])
		&&
		(
			s[x] == '{'
			||
			s[x] == semicolon
		)
		;
		(
			!(prev[1] = 0)
		)
	;>
	<
		(assignation[y] = s[x + y])
		&& 
		(
			s[x + y] != '{' 
			&& 
			s[x + y] != semicolon)
		;
		(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1)))
		&&
		!(assignation[y] = 0)
	;>
	<x
	; 
	!isspace(s[x + y]) && (--x || 1);>
	<s[x + y] == "await"[y]							; 	y == 4;>
		<(name[y] = s[x + y]) && y < 8 && s[x + y]	
		;	
		s[x + y] == '(' 
		&&
		!(
			(name[y] = 0)
			||
			(m_parenthesis_level = 0)
		)
		;>
				<(args[y] = s[x + y]) 
				&&
				(((s[x + y] == '(')
				&&
				++m_parenthesis_level) || 1)
				;
					(
						s[x + y] == ')'
						&&
						!(m_parenthesis_level < 0)
					)
					&& 
					!(
						(args[y] = 0) 
						||
						(m_brace_level = 0)
					)
				;>
					<(body[y] = s[x + y])
						&&
						(
							(
								(s[x + y] == '{' && ++m_brace_level)
								|| 		
								(s[x + y] == '}' && (m_brace_level-- || 1))
							) 
							|| 1
						)
					;	
						(s[x + y] == '}' && m_brace_level < 0)
						&&
						!(body[y] = 0)
					;>
'
	body='
	char	*o;


	
	asprintf(&o, "%s\n%s(%s%s ^(typeof(%s(%s%s 0)) %s) { %s });\n}",
		cat (prev), cat(name), cat(args), strlen(cat(args)) ? "," : "", cat(name), cat(args), strlen(cat(args)) ? "," : "",  lastword(cat(assignation)), cat(body));

	return (o);
']
961:	int
962:	bar
963:	(
964:	int
965:	p
966:	,
967:	void
968:	(
969:	^ptr
970:	)
971:	(
972:	int
973:	k
974:	)
975:	)
976:	{
977:	ptr
978:	(
979:	21
980:	)
981:	;
982:	return
983:	(
984:	0
985:	)
986:	;
987:	}
988:	int
989:	foo
990:	(
991:	int
992:	p
993:	,
994:	char
995:	c
996:	,
997:	void
998:	(
999:	^ptr
1000:	)
1001:	(
1002:	int
1003:	k
1004:	)
1005:	)
1006:	{
1007:	ptr
1008:	(
1009:	42
1010:	)
1011:	;
1012:	return
1013:	(
1014:	0
1015:	)
1016:	;
1017:	}
1018:	int
1019:	main
main begins at 1018
1020:	(
1021:	int
1022:	ac
1023:	,
1024:	char
1025:	*
1026:	*
1027:	av
1028:	)
1029:	{
1030:	printf
1031:	(
1032:	"
1033:	Good
1034:	 
1035:	night
1036:	 
1037:	dear
1038:	 
1039:	bb
1040:	.
1041:	 
1042:	Hallo
1043:	 
1044:	joe
1045:	 
1046:	10101
1047:	;
1048:	 
1049:	Hallo
1050:	 
1051:	ddd
1052:	;
1053:	"
1054:	)
1055:	;
1056:	{
1057:	bar
1058:	(
1059:	10
1060:	,
1061:	^
1062:	(
1063:	typeof
1064:	(
1065:	bar
1066:	(
1067:	10
1068:	,
1069:	0
1070:	)
1071:	)
1072:	i
1073:	)
1074:	{
1075:	;
1076:	printf
1077:	(
1078:	"
1079:	a
1080:	:
1081:	 
1082:	%i
1083:	\
1084:	n
1085:	"
1086:	,
1087:	i
1088:	)
1089:	;
1090:	foo
1091:	(
1092:	21
1093:	,
1094:	'
1095:	c
1096:	'
1097:	,
1098:	^
1099:	(
1100:	typeof
1101:	(
1102:	foo
1103:	(
1104:	21
1105:	,
1106:	'
1107:	c
1108:	'
1109:	,
1110:	0
1111:	)
1112:	)
1113:	z
1114:	)
1115:	{
1116:	;
1117:	printf
1118:	(
1119:	"
1120:	b
1121:	:
1122:	 
1123:	%i
1124:	\
1125:	n
1126:	"
1127:	,
1128:	z
1129:	)
1130:	;
1131:	}
1132:	)
1133:	;
1134:	}
1135:	)
1136:	;
1137:	}
1138:	return
1139:	(
1140:	0
1141:	)
1142:	;
1143:	}
pattern=
	< s[x+y] == 0 ; 0 ;>
 - body=
	return (cat("!! "));

pattern=
	<s[x + y] == "Hello "[y]				;	y == 5;>
		<(test2[y] = s[x + y]) && y < 5		;	s[x + y] == "!"[0]	&& !(test2[y] = 0);>
 - body=
	m_state_test += 1;
	return(cat("Good night dear ", test2, "."));

pattern=
	<
		(prev[0] = s[x])
		&&
		(
			s[x] == '{'
			||
			s[x] == semicolon
		)
		;
		(
			!(prev[1] = 0)
		)
	;>
	<
		(assignation[y] = s[x + y])
		&& 
		(
			s[x + y] != '{' 
			&& 
			s[x + y] != semicolon)
		;
		(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1)))
		&&
		!(assignation[y] = 0)
	;>
	<x
	; 
	!isspace(s[x + y]) && (--x || 1);>
	<s[x + y] == "await"[y]							; 	y == 4;>
		<(name[y] = s[x + y]) && y < 8 && s[x + y]	
		;	
		s[x + y] == '(' 
		&&
		!(
			(name[y] = 0)
			||
			(m_parenthesis_level = 0)
		)
		;>
				<(args[y] = s[x + y]) 
				&&
				(((s[x + y] == '(')
				&&
				++m_parenthesis_level) || 1)
				;
					(
						s[x + y] == ')'
						&&
						!(m_parenthesis_level < 0)
					)
					&& 
					!(
						(args[y] = 0) 
						||
						(m_brace_level = 0)
					)
				;>
					<(body[y] = s[x + y])
						&&
						(
							(
								(s[x + y] == '{' && ++m_brace_level)
								|| 		
								(s[x + y] == '}' && (m_brace_level-- || 1))
							) 
							|| 1
						)
					;	
						(s[x + y] == '}' && m_brace_level < 0)
						&&
						!(body[y] = 0)
					;>
 - body=
	char	*o;


	
	asprintf(&o, "%s\n%s(%s%s ^(typeof(%s(%s%s 0)) %s) { %s });\n}",
		cat (prev), cat(name), cat(args), strlen(cat(args)) ? "," : "", cat(name), cat(args), strlen(cat(args)) ? "," : "",  lastword(cat(assignation)), cat(body));

	return (o);

__________
file .//./build/spec-mvp.ce-compiler.c generated!
cc -g -I./ft_cedille_spec ./build/spec-mvp.ce-compiler.c -o \
			./build/spec-mvp.ce-compiler
valgrind --leak-check=full --show-leak-kinds=all ./build/spec-mvp.ce-compiler\
			./build/spec-mvp.ce .a.txt
out_file=.a.txt fd=3
source_file=./build/spec-mvp.ce fd=4
( !(prev[1] = 0) ) succeed macro_2 122!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 122!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 122!
( !(prev[1] = 0) ) succeed macro_2 151!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 151!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 151!
( !(prev[1] = 0) ) succeed macro_2 182!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 182!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 182!
( !(prev[1] = 0) ) succeed macro_2 217!
( !(prev[1] = 0) ) succeed macro_2 239!
( !(prev[1] = 0) ) succeed macro_2 252!
( !(prev[1] = 0) ) succeed macro_2 277!
( !(prev[1] = 0) ) succeed macro_2 290!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 290!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 290!
y == 5 succeed macro_1 334!
( !(prev[1] = 0) ) succeed macro_2 348!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 348!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 348!
( !(prev[1] = 0) ) succeed macro_2 356!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 356!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 356!
( !(prev[1] = 0) ) succeed macro_2 394!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 394!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 394!
( !(prev[1] = 0) ) succeed macro_2 433!
( !(prev[1] = 0) ) succeed macro_2 438!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 438!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 438!
( !(prev[1] = 0) ) succeed macro_2 458!
( !(prev[1] = 0) ) succeed macro_2 504!
( !(prev[1] = 0) ) succeed macro_2 540!
( !(prev[1] = 0) ) succeed macro_2 548!
( !(prev[1] = 0) ) succeed macro_2 558!
( !(prev[1] = 0) ) succeed macro_2 593!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 593!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 593!
( !(prev[1] = 0) ) succeed macro_2 605!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 605!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 605!
( !(prev[1] = 0) ) succeed macro_2 616!
( !(prev[1] = 0) ) succeed macro_2 655!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 655!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 655!
( !(prev[1] = 0) ) succeed macro_2 665!
( !(prev[1] = 0) ) succeed macro_2 699!
( !(prev[1] = 0) ) succeed macro_2 712!
( !(prev[1] = 0) ) succeed macro_2 750!
( !(prev[1] = 0) ) succeed macro_2 768!
( !(prev[1] = 0) ) succeed macro_2 777!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 777!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 777!
( !(prev[1] = 0) ) succeed macro_2 786!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 786!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 786!
( !(prev[1] = 0) ) succeed macro_2 813!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 813!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 813!
( !(prev[1] = 0) ) succeed macro_2 863!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 863!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 863!
( !(prev[1] = 0) ) succeed macro_2 915!
( !(prev[1] = 0) ) succeed macro_2 934!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 934!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 934!
y == 4 succeed macro_2 934!
s[x + y] == '(' && !( (name[y] = 0) || (m_parenthesis_level = 0) ) succeed macro_2 934!
( s[x + y] == ')' && !(m_parenthesis_level < 0) ) && !( (args[y] = 0) || (m_brace_level = 0) ) succeed macro_2 934!
( !(prev[1] = 0) ) succeed macro_2 1083!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1083!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1083!
( !(prev[1] = 0) ) succeed macro_2 1119!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1119!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1119!
( !(prev[1] = 0) ) succeed macro_2 1148!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1148!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1148!
( !(prev[1] = 0) ) succeed macro_2 1210!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1210!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1210!
( !(prev[1] = 0) ) succeed macro_2 1249!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1249!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1249!
( !(prev[1] = 0) ) succeed macro_2 1361!
( !(prev[1] = 0) ) succeed macro_2 1369!
( !(prev[1] = 0) ) succeed macro_2 1405!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1405!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1405!
( !(prev[1] = 0) ) succeed macro_2 1439!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1439!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1439!
( !(prev[1] = 0) ) succeed macro_2 1448!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1448!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1448!
( !(prev[1] = 0) ) succeed macro_2 1499!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1499!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1499!
( !(prev[1] = 0) ) succeed macro_2 1589!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1589!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1589!
( !(prev[1] = 0) ) succeed macro_2 1694!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1694!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1694!
( !(prev[1] = 0) ) succeed macro_2 1858!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1858!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1858!
( !(prev[1] = 0) ) succeed macro_2 1936!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 1936!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 1936!
( !(prev[1] = 0) ) succeed macro_2 2060!
(s[x + y] == '=' || ((s[x + y] == 'a' && s[x + y + 1] == 'w') && (--x || 1))) && !(assignation[y] = 0) succeed macro_2 2060!
!isspace(s[x + y]) && (--x || 1) succeed macro_2 2060!
( !(prev[1] = 0) ) succeed macro_2 2143!
( !(prev[1] = 0) ) succeed macro_2 2148!
( !(prev[1] = 0) ) succeed macro_2 2158!
( !(prev[1] = 0) ) succeed macro_2 2216!
( !(prev[1] = 0) ) succeed macro_2 2223!
( !(prev[1] = 0) ) succeed macro_2 2387!
( !(prev[1] = 0) ) succeed macro_2 2401!
( !(prev[1] = 0) ) succeed macro_2 2446!
( !(prev[1] = 0) ) succeed macro_2 2456!
( !(prev[1] = 0) ) succeed macro_2 2469!
( !(prev[1] = 0) ) succeed macro_2 2524!
( !(prev[1] = 0) ) succeed macro_2 2534!
( !(prev[1] = 0) ) succeed macro_2 2547!
( !(prev[1] = 0) ) succeed macro_2 2580!
( !(prev[1] = 0) ) succeed macro_2 2627!
( !(prev[1] = 0) ) succeed macro_2 2638!
( !(prev[1] = 0) ) succeed macro_2 2641!
( !(prev[1] = 0) ) succeed macro_2 2645!
( !(prev[1] = 0) ) succeed macro_2 2682!
( !(prev[1] = 0) ) succeed macro_2 2684!
( !(prev[1] = 0) ) succeed macro_2 2708!
( !(prev[1] = 0) ) succeed macro_2 2755!
( !(prev[1] = 0) ) succeed macro_2 2757!
( !(prev[1] = 0) ) succeed macro_2 2781!
( !(prev[1] = 0) ) succeed macro_2 2788!
( !(prev[1] = 0) ) succeed macro_2 2792!
( !(prev[1] = 0) ) succeed macro_2 2807!
cp .a.txt ./build/spec-mvp.ce
((cmp .a.txt .b.txt) || (make spec-mvp.ce))
rm .a.txt
rm .b.txt
cp ./build/spec-mvp.ce ./build/spec-mvp.ce.c 
cc -I./ft_cedille_spec  ./build/spec-mvp.ce.c  && ./a.out 
Good night dear bb. Hallo joe 10101; Hallo ddd;a: 21
b: 42
echo "yayy spec-mvp.co"
yayy spec-mvp.co
rm "./build/spec-mvp.ce"
